"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("../fs");
const pathExists_1 = require("./pathExists");
const mkdirs_1 = require("./mkdirs");
const symlinkAtomic_1 = require("./symlinkAtomic");
async function createSymlink(source, destination, type, atomic = false) {
    if (await pathExists_1.default(destination))
        return;
    if (typeof type === 'boolean')
        [atomic, type] = [type, undefined];
    await mkdirs_1.default(path_1.dirname(destination));
    const relativePath = await symlinkPaths(source, destination);
    const symlinkMethod = atomic ? symlinkAtomic_1.default : fs_1.symlink;
    await symlinkMethod(relativePath.toDst, path_1.resolve(destination), type || await symlinkType(relativePath.toCwd));
}
exports.default = createSymlink;
const symlinkPaths = async (srcpath, dstPath) => {
    if (path_1.isAbsolute(srcpath)) {
        await fs_1.lstat(srcpath);
        return { toCwd: srcpath, toDst: srcpath };
    }
    const dstDir = path_1.dirname(dstPath);
    const relativeToDst = path_1.join(dstDir, srcpath);
    /* istanbul ignore next: Doesn't get tested on all OSs */
    if (await pathExists_1.default(relativeToDst))
        return { toCwd: relativeToDst, toDst: srcpath };
    await fs_1.lstat(srcpath);
    return { toCwd: srcpath, toDst: path_1.relative(dstDir, srcpath) };
};
const symlinkType = async (srcpath) => {
    try {
        const stats = await fs_1.lstat(srcpath);
        return stats.isDirectory() ? 'dir' : 'file';
    }
    catch (err) {
        /* istanbul ignore next: Windows */
        return 'file';
    }
};
//# sourceMappingURL=createSymlink.js.map